# @about-me/fp - 使用指南

TypeScript 函数式编程工具库，提供 11 个核心 FP 工具。

## 导入

```typescript
import { pipe, compose, curry, tap, memoize } from '@about-me/fp'
```

---

## 函数分类和快速参考

### 组合函数（Composition）
- `pipe` - 从左到右组合函数（数据流向）
- `pipeAsync` - 异步版本的 pipe，支持 Promise
- `compose` - 从右到左组合函数（数学风格）

### 函数转换（Function Transformation）
- `curry` - 柯里化：多参数函数 → 单参数函数序列
- `partial` - 部分应用：固定函数的部分参数

### 调试工具（Debugging）
- `tap` - 执行副作用但不改变值（用于调试）

### 基础工具（Utilities）
- `identity` - 返回输入值本身
- `constant` - 返回常量函数

### 性能优化（Performance）
- `memoize` - 缓存函数结果（避免重复计算）
- `debounce` - 防抖（延迟执行，适合搜索输入）
- `throttle` - 节流（限制执行频率，适合滚动事件）

---

## 详细 API 参考

### 1. pipe - 从左到右的函数组合

**签名**：
```typescript
pipe<T>(value: T, ...fns: Array<(arg: any) => any>): any
```

**用途**：创建数据处理管道，从左到右依次应用函数

**使用场景**：
- 数据转换流程
- 多步骤处理
- 清晰的数据流向

**代码示例**：
```typescript
// 基础用法
const result = pipe(
  5,
  x => x * 2,      // 10
  x => x + 10,     // 20
  x => x / 2       // 10
) // 结果: 10

// 实际应用：用户数据处理
const processUser = (userData) => pipe(
  userData,
  validateUser,
  normalizeEmail,
  hashPassword,
  saveToDatabase
)

// 数组处理
const numbers = pipe(
  [1, 2, 3, 4, 5],
  arr => arr.filter(x => x > 2),
  arr => arr.map(x => x * 2),
  arr => arr.reduce((sum, x) => sum + x, 0)
) // 24
```

---

### 2. pipeAsync - 异步函数组合

**签名**：
```typescript
pipeAsync<T>(value: T, ...fns: Array<(arg: any) => any | Promise<any>>): Promise<any>
```

**用途**：组合异步函数，按顺序执行

**使用场景**：
- API 调用链
- 数据库操作
- 异步数据转换

**代码示例**：
```typescript
// API 调用链
const result = await pipeAsync(
  userId,
  fetchUserById,           // async
  validateUser,            // sync
  enrichWithProfile,       // async
  saveToDatabase          // async
)

// 文件处理
const processFile = async (filename) => await pipeAsync(
  filename,
  readFile,               // async
  parseJSON,              // sync
  validateSchema,         // sync
  transformData,          // sync
  writeToDatabase         // async
)
```

---

### 3. compose - 从右到左的函数组合

**签名**：
```typescript
compose<T>(...fns: Array<(arg: any) => any>): (value: T) => any
```

**用途**：数学风格的函数组合（f ∘ g = f(g(x))）

**使用场景**：
- 数学计算
- 需要先定义组合，后传入数据

**代码示例**：
```typescript
// 基础用法（注意执行顺序是从右到左）
const double = (x: number) => x * 2
const addTen = (x: number) => x + 10
const compute = compose(addTen, double)
compute(5) // (5 * 2) + 10 = 20

// 创建可复用的转换函数
const processData = compose(
  JSON.stringify,    // 3. 最后序列化
  normalizeData,     // 2. 然后标准化
  parseCSV          // 1. 先解析 CSV
)

processData(csvString)
```

---

### 4. curry - 柯里化

**签名**：
```typescript
curry(fn: (...args: any[]) => any): (...args: any[]) => any
```

**用途**：将多参数函数转换为单参数函数序列

**使用场景**：
- 创建专用函数
- 参数复用
- 函数式编程风格

**代码示例**：
```typescript
// 基础用法
const add = (a: number, b: number, c: number) => a + b + c
const curriedAdd = curry(add)

curriedAdd(1)(2)(3)        // 6
curriedAdd(1, 2)(3)        // 6
curriedAdd(1)(2, 3)        // 6

// 创建专用函数
const add5 = curriedAdd(5)
add5(10)(3)                // 18
add5(2, 3)                 // 10

// 实际应用：数据过滤
const filterBy = curry((prop, value, arr) =>
  arr.filter(item => item[prop] === value)
)

const users = [
  { name: 'Alice', role: 'admin' },
  { name: 'Bob', role: 'user' },
  { name: 'Charlie', role: 'admin' }
]

const getAdmins = filterBy('role')('admin')
getAdmins(users) // [{ name: 'Alice', ... }, { name: 'Charlie', ... }]

const getByName = filterBy('name')
getByName('Bob')(users) // [{ name: 'Bob', role: 'user' }]
```

---

### 5. partial - 部分应用

**签名**：
```typescript
partial<T>(fn: T, ...fixedArgs: any[]): (...remainingArgs: any[]) => any
```

**用途**：固定函数的部分参数

**使用场景**：
- 简单的参数预填充
- 比 curry 更直接

**代码示例**：
```typescript
// 基础用法
const multiply = (a: number, b: number, c: number) => a * b * c
const multiplyBy2 = partial(multiply, 2)
multiplyBy2(3, 4) // 2 * 3 * 4 = 24

// 实际应用：日志函数
const log = (level: string, module: string, message: string) => {
  console.log(`[${level}] [${module}] ${message}`)
}

const errorLog = partial(log, 'ERROR')
const userError = partial(errorLog, 'USER')

userError('Login failed') // [ERROR] [USER] Login failed

// API 请求
const apiRequest = (method: string, endpoint: string, data: any) => {
  return fetch(endpoint, { method, body: JSON.stringify(data) })
}

const postRequest = partial(apiRequest, 'POST')
postRequest('/api/users', { name: 'Alice' })
```

---

### 6. tap - 执行副作用

**签名**：
```typescript
tap<T>(fn: (value: T) => void): (value: T) => T
```

**用途**：在数据流中执行副作用（如日志、调试），但不改变数据

**使用场景**：
- 调试 pipe 链
- 日志记录
- 监控数据流

**代码示例**：
```typescript
// 在 pipe 中调试
const result = pipe(
  [1, 2, 3, 4, 5],
  tap(x => console.log('Original:', x)),
  arr => arr.map(x => x * 2),
  tap(x => console.log('After double:', x)),
  arr => arr.filter(x => x > 5),
  tap(x => console.log('After filter:', x)),
  arr => arr.reduce((sum, x) => sum + x, 0)
)
// 控制台输出：
// Original: [1, 2, 3, 4, 5]
// After double: [2, 4, 6, 8, 10]
// After filter: [6, 8, 10]
// 结果: 24

// 性能监控
const processData = pipe(
  data,
  tap(() => console.time('validation')),
  validateData,
  tap(() => console.timeEnd('validation')),
  tap(() => console.time('transformation')),
  transformData,
  tap(() => console.timeEnd('transformation'))
)
```

---

### 7. identity - 返回输入值

**签名**：
```typescript
identity<T>(value: T): T
```

**用途**：返回输入值本身，不做任何改变

**使用场景**：
- 过滤假值
- 默认函数
- 函数组合的占位符

**代码示例**：
```typescript
// 基础用法
identity(42)        // 42
identity("hello")   // "hello"
identity([1, 2])    // [1, 2]

// 过滤假值
const data = [1, 2, null, 3, undefined, 4, 0, false, 5]
data.filter(identity) // [1, 2, 3, 4, 5]

// 默认函数
const applyTransform = (value, transform = identity) => transform(value)
applyTransform(10)           // 10
applyTransform(10, x => x * 2) // 20

// 提取数组中的值
const pairs = [['a', 1], ['b', 2], ['c', 3]]
pairs.map(([key, value]) => value) // 可以简化为:
pairs.map(identity) // 当需要保持原样时
```

---

### 8. constant - 返回常量函数

**签名**：
```typescript
constant<T>(value: T): () => T
```

**用途**：创建一个始终返回相同值的函数

**使用场景**：
- 默认值
- 数组填充
- 事件处理

**代码示例**：
```typescript
// 基础用法
const getTrue = constant(true)
getTrue() // true
getTrue() // true

const get42 = constant(42)
get42() // 42

// 数组填充
[1, 2, 3].map(constant('x'))     // ['x', 'x', 'x']
Array(5).fill(0).map(constant({})) // [{}, {}, {}, {}, {}]

// 默认值
const getUserRole = (user) => user.role || constant('guest')()

// React 事件处理
<button onClick={constant(console.log('Clicked!'))}>
  Click me
</button>
```

---

### 9. memoize - 缓存函数结果

**签名**：
```typescript
memoize<T, R>(fn: (arg: T) => R): (arg: T) => R
```

**用途**：缓存函数结果以避免重复计算（仅支持单参数函数）

**使用场景**：
- 昂贵的计算
- 递归优化
- API 响应缓存

**代码示例**：
```typescript
// 斐波那契数列优化
const fibonacci = memoize((n: number): number => {
  if (n <= 1) return n
  return fibonacci(n - 1) + fibonacci(n - 2)
})

fibonacci(40) // 第一次计算
fibonacci(40) // 立即返回缓存结果

// 昂贵的数据转换
const processLargeData = memoize((data: string) => {
  // 复杂的解析和转换
  return JSON.parse(data).map(transform).filter(validate)
})

// API 响应缓存
const fetchUser = memoize(async (userId: string) => {
  const response = await fetch(`/api/users/${userId}`)
  return response.json()
})

// 同一用户多次调用，只发送一次请求
fetchUser('123')
fetchUser('123') // 使用缓存
```

---

### 10. debounce - 防抖

**签名**：
```typescript
debounce<T>(fn: T, delayMs: number): (...args: Parameters<T>) => void
```

**用途**：延迟执行函数，直到停止调用一段时间后才执行

**使用场景**：
- 搜索输入框
- 自动保存
- 窗口调整大小

**代码示例**：
```typescript
// 搜索输入
const searchAPI = debounce((query: string) => {
  fetch(`/api/search?q=${query}`)
}, 300)

input.addEventListener('input', (e) => searchAPI(e.target.value))
// 用户快速输入 "hello"，只有最后一次在 300ms 后执行

// 自动保存
const autoSave = debounce((content: string) => {
  localStorage.setItem('draft', content)
}, 1000)

textarea.addEventListener('input', (e) => autoSave(e.target.value))

// 窗口调整大小
const handleResize = debounce(() => {
  console.log('Window resized to:', window.innerWidth)
}, 500)

window.addEventListener('resize', handleResize)
```

---

### 11. throttle - 节流

**签名**：
```typescript
throttle<T>(fn: T, delayMs: number): (...args: Parameters<T>) => void
```

**用途**：限制函数执行频率，每隔一段时间最多执行一次

**使用场景**：
- 滚动事件
- 鼠标移动
- 频繁触发的事件

**代码示例**：
```typescript
// 滚动事件
const logScroll = throttle(() => {
  console.log('Scroll position:', window.scrollY)
}, 1000)

window.addEventListener('scroll', logScroll)
// 无论滚动频率如何，每秒最多执行一次

// 鼠标移动
const trackMouse = throttle((e: MouseEvent) => {
  console.log('Mouse at:', e.clientX, e.clientY)
}, 100)

document.addEventListener('mousemove', trackMouse)

// API 请求限制
const sendAnalytics = throttle((event: string) => {
  fetch('/api/analytics', {
    method: 'POST',
    body: JSON.stringify({ event })
  })
}, 5000)

// 频繁点击，但每 5 秒最多发送一次
button.addEventListener('click', () => sendAnalytics('button_click'))
```

---

## 组合使用示例

### 示例 1：用户注册流程

```typescript
import { pipe, tap, pipeAsync } from '@about-me/fp'

// 同步验证
const validateRegistration = pipe(
  input,
  tap(x => console.log('Input:', x)),
  validateEmail,
  validatePassword,
  tap(x => console.log('Validated:', x)),
  sanitizeInput
)

// 异步处理
const processRegistration = async (data) => await pipeAsync(
  data,
  validateRegistration,
  checkEmailExists,
  hashPassword,
  createUser,
  sendWelcomeEmail
)
```

### 示例 2：数据处理管道

```typescript
import { pipe, curry, tap, memoize } from '@about-me/fp'

// 创建过滤器
const filterBy = curry((prop, value, arr) =>
  arr.filter(item => item[prop] === value)
)

// 缓存昂贵的转换
const transformData = memoize((data) => {
  return pipe(
    data,
    tap(x => console.log('Processing:', x.length, 'items')),
    filterBy('active')(true),
    arr => arr.map(enrichWithMetadata),
    arr => arr.sort((a, b) => b.score - a.score),
    tap(x => console.log('Result:', x.length, 'items'))
  )
})
```

### 示例 3：搜索功能

```typescript
import { debounce, pipe, tap } from '@about-me/fp'

const processSearch = pipe(
  query => query.trim().toLowerCase(),
  tap(x => console.log('Search query:', x)),
  searchDatabase,
  filterResults,
  sortByRelevance
)

const debouncedSearch = debounce(processSearch, 300)

searchInput.addEventListener('input', (e) => {
  debouncedSearch(e.target.value)
})
```

---

## 最佳实践

### 1. 优先使用 pipe 而不是嵌套调用

不推荐：
```typescript
const result = transform3(transform2(transform1(data)))
```

推荐：
```typescript
const result = pipe(
  data,
  transform1,
  transform2,
  transform3
)
```

### 2. 使用 tap 进行调试

```typescript
const result = pipe(
  data,
  transform1,
  tap(x => console.log('After transform1:', x)), // 调试点
  transform2,
  tap(x => console.log('After transform2:', x))  // 调试点
)
```

### 3. 组合 curry 和 pipe 创建可复用函数

```typescript
const filterBy = curry((prop, value, arr) =>
  arr.filter(item => item[prop] === value)
)

const processUsers = pipe(
  filterBy('active')(true),
  users => users.map(enrichUser),
  users => users.sort(byName)
)
```

### 4. 使用 memoize 优化昂贵计算

```typescript
const expensiveComputation = memoize((data) => {
  // 复杂计算
  return result
})
```

### 5. 对用户输入使用 debounce

```typescript
const handleSearch = debounce((query) => {
  searchAPI(query)
}, 300)
```

### 6. 对高频事件使用 throttle

```typescript
const handleScroll = throttle(() => {
  updateScrollIndicator()
}, 100)
```

---

## 类型安全

所有函数都有完整的 TypeScript 类型定义：

```typescript
// 类型推导
const result = pipe(
  5,           // number
  x => x * 2,  // number -> number
  x => String(x) // number -> string
) // result 类型为 string

// 泛型支持
const memoized = memoize((x: number) => x * 2)
// memoized 类型为 (arg: number) => number
```

---

## 注意事项

1. **memoize 仅支持单参数函数**
   - 如需多参数，使用 curry 或 partial 先转换

2. **debounce 和 throttle 会丢失返回值**
   - 它们主要用于副作用，不适合需要返回值的场景

3. **pipe 和 compose 的参数顺序相反**
   - pipe: 从左到右（数据流向）
   - compose: 从右到左（数学风格）

4. **pipeAsync 会等待所有异步操作完成**
   - 确保每个函数都正确处理错误

---

## 常见模式

### 模式 1：条件执行

```typescript
const processData = (data, shouldTransform) => pipe(
  data,
  x => shouldTransform ? transform(x) : x,
  normalize,
  validate
)
```

### 模式 2：错误处理

```typescript
const safeProcess = async (data) => {
  try {
    return await pipeAsync(
      data,
      validate,
      transform,
      save
    )
  } catch (error) {
    console.error('Processing failed:', error)
    return null
  }
}
```

### 模式 3：组合多个工具

```typescript
const smartSearch = debounce(
  curry((filters, query, dataset) =>
    pipe(
      dataset,
      filterBy('query')(query),
      filterBy('category')(filters.category),
      sortByRelevance
    )
  ),
  300
)
```

